## 

システムは自分自身では動かないということは普遍的に認められている事実です。
では、

- **システム、特に大規模に動作する複雑なコンピューティングシステムは、どのように実行されるべきなのでしょうか？**





## The Sysadmin Approach to Service Management

歴史的に、企業は複雑なコンピュータシステムを実行するためにシステム管理者を雇用してきました。

このシステム管理者（システム管理者）のアプローチでは、

- 既存のソフトウェアコンポーネントを組み立て、サービスを生成するためにそれらを一緒に動作するように配置すること

が含まれます。



システム管理者は、

> サービスを実行し、発生したイベントや更新に対応することを任務としています。



システムが複雑さとトラフィック量を増し、イベントや更新が増加すると、システム管理者チームは追加の作業を吸収するために成長します。





システム管理者の役割は、

>  製品の開発者に必要とされるスキルセットとは著しく異なるスキルセットを必要とするため、開発者とシステム管理者は別々のチームに分けられます。
>
> - "開発」
> - 「運用」または「OPS」



メリット

サービス管理のシステム管理者モデルには、いくつかの利点があります。
サービスをどのように運営し、スタッフを配置するかを決定している企業にとって、このアプローチは比較的簡単に実装することができます。
をエミュレートします。関連する人材プールが既に広く利用可能である。

既存のツール、ソフトウェアコンポーネント（既製品であってもそうでなくても）、統合会社が、これらの組み立てられたシステムの実行を支援するために利用可能なので、初心者のシスアドチームは、車輪を再発明してゼロからシステムを設計する必要はありません。



デメリット

システム管理者のアプローチとそれに伴う開発/運用の分割には、多くの欠点と落とし穴があります。

これらは大きく分けて2つのカテゴリに分類されます: 

- 直接コスト
- 間接コスト

です。



直接コストは微妙でも曖昧でもありません。

> 変更管理とイベント処理の両方を手作業に頼っているチームでサービスを運営していると、サービスやサービスへのトラフィックが大きくなるにつれてコストが高くなります。



開発/運用の分割の間接的なコストは微妙ですが、組織にとっては直接的なコストよりも高額になることが多いです。



これらのコストは、2つのチームが

- 背景
- スキルセット
- インセンティブ

が全く異なるという事実から生じる。



状況を説明するために

- 異なる語彙を使用し、
- リスクと技術的解決策の可能性の両方について異なる仮定を持ち、
- 製品の安定性の目標レベルについて異なる仮定を持っています。



グループ間の分裂は、

- インセンティブだけでなく、
- コミュニケーション
- 目標

そして最終的には信頼と尊敬の問題になりやすい。

この結果は病理である。



このように、

従来のオペレーションチームと製品開発チームの間では、

- **ソフトウェアをいかに早く製品にリリースできるかという点で対立が生じることがよくあります。**



開発チームは、

- **新機能をリリースしてユーザーに採用されたいと考えています。**



運用チームは、

- **ポケベルを持っている間にサービスが壊れないことを確認したいと考えています。**



ほとんどの停止は、

- 新しい設定、
- 新機能の立ち上げ、
- または新しいタイプのユーザー・トラヒックなどの何らかの変化

によって引き起こされるため、

**2 つのチームの目標は根本的に緊張状態にあります。**

両チームとも、

- **自分たちの利益を可能な限りはっきりとした言葉で表現することは受け入れられないことを理解しています**

（「いつでも、何でも、何の支障もなく起動させたい」と「システムが動作したら、何も変更したくない」ということです）。



そして、彼らの

- 語彙
- リスクの前提条件

異なるため、両グループはしばしば自分たちの利益を前進させるために、お馴染みの塹壕戦の形に頼る。



運用チームは、

- **起動と変更のゲートを導入することで、変更のリスクに対して実行中のシステムを保護しようとします。**

> 例えば、起動時のレビューでは、過去に障害を引き起こしたことのあるすべての問題を明示的にチェックすることができます。

開発チームは、

- **どのように対応すべきかをすぐに知ることができます。**

開発チームは

- 「起動」

を減らし、



- 「フラグの反転」
- 「インクリメンタルアップデート」
- 「チェリーピック」

を増やしています。

製品をシャーディングして、ローンチレビューの対象となる機能が少なくなるようにするなどの戦術を採用します。











## Google's Approach to Service Management: Site Reliability Engineering 



ソフトウェアサービスを提供する上で、紛争は避けられないものではありません。

Googleのサイト信頼性エンジニアリングチームは、

- **ソフトウェアエンジニアを採用して製品を稼働させ、通常はシスアドが手作業で行っていた作業を達成するためのシステムを構築することに注力しています。**



**Googleで定義されるようになったサイト信頼性エンジニアリングとは、具体的にはどのようなものなのでしょうか？**

SREとは、

- **ソフトウェアエンジニアに運用チームの設計を依頼することです。**

  

> 私が2003年にGoogleに入社し、7人のエンジニアからなる「プロダクションチーム」の運営を任されたとき、それまでの私の人生はソフトウェアエンジニアリングでした。
>
> そのため、私自身がSREとして働いていたときのような形でグループを設計し、運営しました。
>
> そのグループはその後、Googleの現在のSREチームに成長しました。
>
> 


サービス管理に対する Google のアプローチの主要な構成要素は、各 SRE チームの構成です。

全体として、SRE は主に 2 つのカテゴリーに分けることができます。

- 50～60%はGoogleソフトウェアエンジニア、より正確にはGoogleソフトウェアエンジニアの標準的な手順で採用された人たちである。

- 残りの40～50％は、Googleソフトウェアエンジニアの資格に非常に近い（すなわち、必要とされるスキルセットの85～99％）候補者であり、それに加えて、SREには有用だが、ほとんどのソフトウェアエンジニアにとっては珍しい技術的なスキルセットを持っていた人たちである。

  

我々が求める代替技術スキルの中で最も一般的なのは、UNIX システム内部とネットワーク（レイヤ 1 からレイヤ 3）の専門知識の 2 つです。



すべてのSREに共通しているのは、

- **複雑な問題を解決するためにソフトウェアシステムを開発するという信念と適性です。**



SREでは、この2つのグループのキャリアの進捗状況を綿密に追跡していますが、これまでのところ、この2つのトラックのエンジニア間でパフォーマンスに実質的な差は見られませんでした。



実際、SREチームの背景がやや多様であることから、巧妙で高品質なシステムが頻繁に生み出されていますが、それは明らかに複数のスキルセットの合成によるものです。



私たちのSREの採用アプローチの結果、

- (a) 手作業ではすぐに飽きてしまい、
- (b) 複雑な解決策であっても、それまでの手作業に代わるソフトウェアを書けるだけのスキルを持った人たち

が集まってきました。



また、SREは、開発組織の他のメンバーと学歴や知的背景を共有することになります。

したがって、SRE は、従来はオペレーションチームが行っていた業務を、ソフトウェアの専門知識を持ったエンジニアを使ってファンダメンタル的に行い、また、これらのエンジニアが



SRE チームは、

- **人間の労働力に代わるソフトウェアによる自動化を設計し、実装する能力を本質的に持っています。**



設計上、

- **SRE チームがエンジニアリングに集中していることが重要です。**



継続的なエンジニアリングがなければ、

- 業務負荷は増加し、
- チームは業務負荷に追いつくために人員を増やさなければならなくなります。
- 最終的には、従来のオペレーションに焦点を当てたグループは、サービスの規模に応じて直線的に拡大していきます。



サービスがサポートする製品が成功すれば、

- 運用負荷はトラフィックに応じて増加します。



これは、同じ作業を何度も何度も行うために、より多くの人員を雇用することを意味します。



このような運命を避けるために、サービスを管理するチームはコーディングをする必要があります。

そのため、Google はすべての SRE（チケット、オンコール、マニュアルタスクなど）の総「OPS」作業に 50% の上限を設けています。



この上限は、

- **SREチームがサービスを安定して操作可能な状態にするために十分な時間をスケジュールに確保することを保証します。**

この上限は上限であり、時間が経つにつれて、SREチームは運用負荷がほとんどなく、ほとんど開発タスクに従事しなくてはなりません。



実際には、規模の拡大や新機能の追加により、SREは気を緩めないようにしています。



Googleの経験則では、SREチームは残りの50%の時間を

- 開発に費やす必要があります。



では、**この閾値をどのようにして強制するのでしょうか？**



まず第一に、SREの時間がどのように費やされているかを測定する必要があります。

その測定結果をもとに、開発業務に費やしている時間が一貫して50%未満であるチームが、プラクティスを変更するようにします。

多くの場合、

- これは運用負担の一部を開発チームにシフトしたり、
- チームに追加の運用責任を割り当てずにスタッフを追加したりすることを意味します。

運用業務と開発業務のバランスを意識的に維持することで、

- **SRE が創造的で自律的なエンジニアリングに従事するための帯域幅を確保しつつ、サービスを運営する上での運用サイドから得た知恵を維持することが可能になります。**





大規模システムを動かすためのGoogle SREのアプローチには、多くの利点があることがわかりました。

SRE は Google のシステムを自分たちで動かすことを追求してコードを直接修正しているため、

- **SRE のチームは迅速な革新性と変化の受容性の両方を特徴としています。**



このようなチームは比較的安価であり、**同じサービスをOPS志向のチームにアップポートするには、かなり多くの人数が必要になります。**

その代わり、

- システムの運用
- 保守
- 改善

に必要な SRE の数は、システムの規模に応じて従属的に変化します。



最終的に、SRE は開発者と運用担当者が分断されていた機能不全を回避できるだけでなく、

この構造は製品開発チームを改善することにもなります。



このような正味の利益にもかかわらず、SRE モデルには

- **独自の課題があるのが特徴です。**

Google が直面している継続的な課題の 1 つは、

- **SRE の採用です。**

  

製品開発の採用パイプラインと同じ候補者を競い合っていますが、

- コーディング
- システム
- エンジニアリング
- スキル

両方の面で採用基準を非常に高く設定しているという事実は、当社の採用プールが必ずしも少ないことを意味しています。



私たちの分野は比較的新しく、ユニークなものであるため、SREチームをどのように構築し、管理するかについての業界の情報はあまりありません（ただし、本書がその方向性を前進させてくれることを期待しています）。

また、一度SREチームが設置されると、

- **サービス管理に対する彼らの潜在的に異例なアプローチには、強力な管理者のサポートが必要になります。**

> 例えば、エラー予算が枯渇したら、四半期の残りのリリースを停止するという決定は、製品開発チームが経営陣の命令を受けない限り、受け入れられないかもしれません。





## DevOps or SRE？

DevOps」という用語は

> 2008年後半に業界に登場しましたが、この記事を書いている時点（2016年初頭）ではまだ流動的な状態にあります。

その中核となる原則、すなわち、

- システムの設計と開発の各フェーズにIT機能を関与させ、人手を必要としない自動化に大きく依存し、エンジニアリング・プラクティスとツールを運用タスクに適用することは、SREの原則と実践の多くと一致しています。



DevOps は、いくつかの SRE のコアとなる原則を、より広範な組織、管理構造、人材に一般化したものと考えることができます。

また、SREをDevOpsの特定の実装にいくつかの特殊な拡張を加えたものと見なすこともできます。









## Tenets of SRE

- ワークフロー、
- 優先順位、
- および日々の運用のニュアンス

 SRE チームによって異なりますが、すべての SRE チームは自分たちが担当するサービスに対する基本的な責任を共有しており、同じコア・テニュアを順守しています。

一般的に、SRE チームは、

- サービスの可用性、
- レイテンシー、
- パフォーマンス、
- 効率性、
- 変更管理、
- 監視、
- 緊急時の対応、
- およびキャパシティプランニング

に責任を負います。



私たちは、SREチームが本番環境だけでなく、

- 製品開発チーム、
- テストチーム、
- ユーザー

などの環境とどのように相互作用するかについての就業規則と原則を成文化しています。



これらの

ルールや作業方法は、

- 運用業務ではなく、
- エンジニアリング業務に

重点を置くことを可能にしてくれます。









## Ensuring a Durable Focus on Engineering



すでに議論されているように、

**GoogleはSREの運用業務の時間を50%に制限している。**

- 残りの時間は、彼らのコーディングスキルを使ってプロジェクト作業に費やすべきである。



実際には、SREが行っている運用業務の量を監視し、過剰な運用業務を製品開発チームにリダイレクトすることで、これを実現している。



リダイレクションは、

> 運用負荷が50%以下に低下した時点で終了する。



これはまた、効果的なフィードバックメカニズムを提供し、開発者が手動介入を必要としないシステムを構築するための指針となります。



このアプローチは、

- 安全弁メカニズムが存在する理由を理解し、
- 製品がそれを必要とするほどの運用負荷を生成しないためにオーバーフローイベントを発生させないという目標をサポートする組織全体（RE と開発者の両方）がうまく機能する場合

に有効です。





SRE が運用作業に集中している場合、平均して、

>  SRE は 8-12 時間のオンコールシフトあたり最大でも 2 つのイベントを受け取るべきである。



この目標量であれば、オンコールエンジニアには、

- イベントを正確かつ迅速に処理し、
- 清掃して通常のサービスを回復させ、
- その後死後診断を行うのに十分な時間を与える

ことができます。



オンコール・シフトごとに 2 つ以上のイベントが定期的に発生する場合、

- 問題を徹底的に調査することができず、
- 技術者は十分に圧倒されて、
- これらのイベントから学習することができなくなります。



ポケベル疲労のシナリオも、規模が大きくなっても改善されません。
逆に、オンコールの SRE がシフトごとに一貫して 1 件未満のイベントを受信している場合、オンコールを維持することは時間の浪費である。



ページャーが発生したかどうかに関わらず、すべての重要なインシデントについて事後報告書を作成すべきである。
ページャーが発生しなかった事後報告書は、明らかなモニタリングのギャップを指摘している可能性が高いため、さらに価値がある。



この調査では、

- 何が起こったのかを詳細に立証し、
- イベントのすべての根本原因を見つけ出し、
- 問題を修正したり、
- 次回以降の対応方法を改善するためのアクションを割り当てる

必要があります。



Google は、

- **欠陥を避けたり最小化したりするのではなく、欠陥を明らかにし、これらの欠陥を修正するためにエンジニアリングを適用することを目的とした、非の打ち所のない死後の文化の下で運営されています。**









## Pursuing Maximum Change Velocity Without Vilolating a Service's SLO

製品開発チームと SRE チームは、それぞれの目標における構造的な対立を解消することで、

- **生産的な作業関係を楽しむことができる。**



構造的な対立とは、

- イノベーションのペースと製品の安定性の間の対立であり、先に述べたように、この対立は間接的に表現されることが多い。



SREでは、

>  この対立を前面に出し、エラーバジェットを導入して解決します。



エラーバジェットは、

> 基本的にすべてのものに対して 100%というのは間違った信頼性目標であるという観察に由来しています（ペースメーカーとアンチロックブレーキは顕著な例外です）。



一般的に、どのようなソフトウェアサービスやシステムにおいても、100%は正しい信頼性目標ではありません。

なぜなら、

- **ユーザーはシステムが100%利用可能なのと99.999%利用可能なのとの違いを見分けることができないからです。**



ユーザーとサービスの間には、他にも多くのシステム（ユーザーのラップトップ、自宅の WiFi、ISP、電力網など）が存在しますが、それらのシステムは総合的に見て 99.999%の利用可能性をはるかに下回っています。



このように、99.999%と100%の間の限界差は、他の利用不可能なシステムのノイズの中に紛れ込んでしまい、

ユーザーは、最後の0.001%の利用可能性を追加するために必要な膨大な労力から何の恩恵も受けられません。



100%がシステムの信頼性目標として間違っているとしたら、システムの正しい信頼性目標は何でしょうか？



これは技術的な質問ではなく、製品の質問であり、以下の点を考慮に入れる必要があります。


- ユーザーが製品をどのように使用しているかを考慮して、どの程度の可用性レベルであれば満足できるか？
- 製品の可用性に不満を持っているユーザーには、どのような代替手段があるのか？
- 異なる可用性レベルでのユーザーの製品使用はどうなるか？



ビジネスまたは製品は、システムの可用性目標を設定しなければなりません。

その目標が設定されると、エラー・バジェットは、可用性目標から1を引いたものになります。



99.99%利用可能なサービスは、0.01%利用不可です。その許可された0.01%の利用不能がサービスのエラーバジェットです。

予算を使いすぎない限り、何にでも予算を使うことができます。

では、エラー予算はどのように使いたいのでしょうか？



開発チームは、

- 機能をローンチして新しいユーザーを獲得したいと考えています。

理想的には、エラー予算のすべてを、迅速にローンチするためにリスクを冒してローンチするものに費やしたいと考えています。

この基本的な前提条件は、エラー予算のモデル全体を説明しています。

SRE活動がこのフレームワークで概念化されるとすぐに、段階的なロールアウトや1%の実験のような戦術でエラーバジェットを解放することで、より迅速なローンチのために最適化することができます。

エラーバジェットの使用は、開発と SRE の間のインセンティブの構造的な対立を解決する。

SRE の目標はもはや「停止ゼロ」ではなく、むしろ SRE とプロジェクト開発者は、エラーバジェットを使って機能のベロシティを最大化することを目標としています。

この変更は、すべての違いをもたらします。

障害はもはや「悪いこと」ではなく、イノベーションのプロセスの一部として期待され、開発チームと SRE チームの両方が恐れるのではなく、管理しなければならない出来事です。











## Monitoring

モニタリングは、

> ービスオーナーがシステムの健全性と可用性を追跡するための主要な手段の一つです。
> そのため、モニタリング戦略は思慮深く構築する必要があります。



モニタリングの古典的で一般的なアプローチは、

> 特定の値や条件を監視し、その値を超えた場合や条件が発生した場合に電子メールアラートを起動することです。





しかし、このタイプの電子メールアラートは効果的なソリューションではありません。

人間が電子メールを読み、それに対して何らかのアクションを取る必要があるかどうかを判断する必要があるシステムは、根本的に欠陥があります。

モニタリングでは、人間がアラート領域のどの部分を解釈する必要はありません。

その代わりに、ソフトウェアが解釈を行うべきであり、人間は行動を起こす必要がある場合にのみ通知されるべきです。





有効な監視出力には3種類あります。

- アラート
  状況を改善するために、人間は今起きていること、またはこれから起きようとしていることに対応して、すぐに行動を起こす必要があることを意味します。

- チケット
  人間が行動を起こす必要があるが、すぐにではないことを示します。システムが自動的に状況を処理することはできませんが、数日後に人間が行動を起こせば、被害は発生しません。

- ロギング
  誰もこの情報を見る必要はありませんが、診断のために記録されています。誰もログを読まないということは、何か他のことをしない限り、誰も読まないということです。







## Emergencey Response



信頼性は、

>  平均故障時間(MTTF)と平均修復時間(MTTR)の関数です[Sch15]。



緊急時対応の有効性を評価する上で最も適切な指標は、

- 対応チームがどれだけ早くシステムを健全な状態に戻すことができるか、つまりMTTRです。



人間は待ち時間を追加します。あるシステムが実際に多くの障害を経験したとしても、人手による介入を必要とする緊急事態を回避できるシステムの方が、人手による介入を必要とするシステムよりも高い可用性を持つことになります。



人手が必要な場合には、「プレイブック」に事前にベストプラクティスを考え抜いて記録しておくことで、MTTR は、「それに従う」戦略と比較して約 3 倍の改善が得られることがわかりました。



ヒーローのオールマイティなオンコールエンジニアはうまくいきますが、プレイブックで武装した実践的なオンコールエンジニアの方がはるかにうまくいきます。



どんなに包括的なプレイブックであっても、その場で考えることができるスマートなエンジニアの代わりにはなりませんが、明確で徹底したトラブルシューティングの手順やヒントは、高額なリスクや時間のかかるページに対応する際には貴重なものとなります。

このように、Google SRE は、「Wheel of Mis-fortune」2 のような演習に加えて、オンコールのプレイブックを利用して、エンジニアがオンコールのイベントに対応できるように準備しています。







## Change Management

SRE は、停止の約 70% がライブシステムの変更によるものであることを発見しました。

このドメインのベストプラクティスでは、自動化を使用して以下のことを実現しています。

- プログレッシブなロールアウトの実施
- 問題点を迅速かつ正確に検出
- 問題が発生した場合に安全に変更をロールバック



この3つのプラクティスは、

- 悪い変更にさらされるユーザーと操作の総数を効果的に最小化します。



人間をループから外すことで、これらのプラクティスは、

- 疲労
- 親しみやすさ/軽蔑
- 反復性の高いタスクへの不注意

といった通常の問題を回避します。

その結果、リリース速度と安全性の両方が向上します。







## Demand Forecasting and Capacity Planning 

需要予測とキャパシティ・プランニングは、

>  予測された将来の需要に必要な可用性を備えた十分なキャパシティと冗長性を確保することと捉えることができます。



これらの概念に特別な意味はないが、驚くほど多くのサービスやチームが、必要とされる時までに必要なキャパシティを確保するために必要なステップを踏んでいないことを除いては、何の問題もない。

キャパシティプランニングでは、

- 有機的な成長（自然な製品の採用や顧客による使用に起因する）
- 無機的な成長（機能の発売、マーケティングキャンペーン、その他のビジネス主導の変更などのイベントに起因する）

両方を考慮に入れる必要がある。



キャパシティ・プランニングには、いくつかのステップが必須である。
- キャパシティ獲得に必要なリードタイムを超えた正確なオーガニック需要予測
- 需要予測への無機質な需要ソースの正確な組み込み
- システムの定期的な負荷テストを行い、生の容量（サーバーやディスクなど）とサービスの容量を相関させる



キャパシティは可用性に不可欠であるため、当然のことながら SRE チームはキャパシティプランニングを担当しなければならず、これはプロビジョニングも担当しなければならないことを意味する。







## Provisioning

プロビジョニングは、

> 変更管理とキャパシティプランニングの両方を兼ね備えています



私たちの経験では、キャパシティにはコストがかかるため、プロビジョニングは迅速に実施し、必要なときだけ実施する必要があります。



この作業も正しく行わなければ、キャパシティは必要なときには機能しません。

新しいキャパシティを追加するには、

- 新しいインスタンスや場所をスピンアップし、
- 既存のシステム（構成ファイル、ロードバランサ、ネットワーキング）に大幅な変更を加え、
- 新しいキャパシティが正しく動作し、正しい結果が得られるかどうかを検証する

必要があります。



このように、多くの場合、ロードシフティングよりもリスクの高い作業です。

1時間に複数回行われ、それに応じて特別な注意を払って処理する必要があります。







## Efficiency and Performance



資源の効率的な利用は、

> サービスがお金を気にするときにはいつでも重要である。

SREは最終的にプロビジョニングをコントロールするため、利用率に関する作業にも関与しなければなりません。



サービスのプロビジョニング戦略に細心の注意を払い、その利用率に注意を払うことは、

- **サービスの総コストに非常に大きな影響を与えることになります。**



リソースの使用は、

- 需要（負荷）
- 容量
- ソフトウェアの効率性

の関数です。



SREは需要を予測し、容量を提供し、ソフトウェアを修正することができます。

これら3つの要因は、サービスの効率性の大部分を占めています（全体ではありませんが）。

ソフトウェアシステムに負荷が加わると、ソフトウェアシステムは遅くなります。

**サービスの速度低下は、キャパシティの損失に相当します。**



ある時点で、遅くなったシステムはサービスを停止し

- これは無限の遅さに相当します。



SRE は、

- 特定の応答速度でキャパシティ・ターゲットを満たすためにサービスを提供するため、サービスのパフォーマンスに強い関心を持っています。



SRE と製品開発者は、サービスのパフォーマンスを向上させるために、

- サービスを監視し、
- 修正する

ことで、キャパシティを追加し、効率を向上させることができる（はずである）。







## The End of the Beginning 

サイト信頼性エンジニアリングは、大規模で複雑なサービスを管理するための既存の業界のベストプラクティスから大きく脱却したものです。

もともとは、「ソフトウェアエンジニアとして、反復的なタスクを達成するために自分の時間を投資したい」という親しみやすさが動機でしたが、今ではそれ以上のものになっています：

- 一連の原則、
- 一連の実践方法、
- 一連のインセンティブ、
- そしてより大きなソフトウェアエンジニアリングの分野における努力

の分野です。

本書の残りの部分では、SRE ウェイについて詳しく説明しています。